import _extends from "@babel/runtime/helpers/extends";

/** @jsx jsx */
import { forwardRef, memo, useCallback, useMemo, useState } from 'react';
import { jsx } from '@emotion/core';
import { useCallbackWithAnalytics } from '@atlaskit/analytics-next';
import EditorCloseIcon from '@atlaskit/icon/glyph/editor/close';
import { ExitingPersistence, ShrinkOut } from '@atlaskit/motion';
import GlobalTheme from '@atlaskit/theme/components';
import { getThemeColors } from '../../../theme'; // eslint-disable-next-line import/order

import { name as packageName, version as packageVersion } from '../../../version.json';
import BaseTag from '../shared/base';
import Before from '../shared/before';
import Content from '../shared/content';
import { chromeLinkStyles, chromeStyles, roundedBorderStyles } from '../shared/styles';
import { mergeRefs } from '../shared/utils';
import { removeButtonStyles } from './styles';

const defaultBeforeRemoveAction = () => true;

const noop = () => {};

var TagStatus;

(function (TagStatus) {
  TagStatus["Showing"] = "showing";
  TagStatus["Removing"] = "removing";
  TagStatus["Removed"] = "removed";
})(TagStatus || (TagStatus = {}));

const InnerRemovableTag = /*#__PURE__*/forwardRef((props, ref) => {
  const [status, setStatus] = useState(TagStatus.Showing);
  const {
    appearance = 'default',
    elemBefore = null,
    isRemovable = true,
    text = '',
    color = 'standard',
    mode = 'light',
    href,
    removeButtonLabel,
    testId,
    onBeforeRemoveAction = defaultBeforeRemoveAction,
    onAfterRemoveAction = noop
  } = props;
  const isRounded = appearance === 'rounded';
  const isLink = Boolean(href);
  const onAfterRemoveActionWithAnalytics = useCallbackWithAnalytics(onAfterRemoveAction, {
    action: 'removed',
    actionSubject: 'tag',
    attributes: {
      componentName: 'tag',
      packageName,
      packageVersion
    }
  }, 'atlaskit');
  const handleRemoveComplete = useCallback(() => {
    onAfterRemoveActionWithAnalytics(text);
    setStatus(TagStatus.Removed);
  }, [onAfterRemoveActionWithAnalytics, text]);
  const handleRemoveRequest = useCallback(() => {
    if (onBeforeRemoveAction && onBeforeRemoveAction()) {
      handleRemoveComplete();
    }
  }, [handleRemoveComplete, onBeforeRemoveAction]);
  const onKeyPress = useCallback(e => {
    const spacebarOrEnter = e.key === ' ' || e.key === 'Enter';

    if (spacebarOrEnter) {
      e.stopPropagation();
      handleRemoveRequest();
    }
  }, [handleRemoveRequest]);
  const removingTag = useCallback(() => setStatus(TagStatus.Removing), []);
  const showingTag = useCallback(() => setStatus(TagStatus.Showing), []);
  const {
    chromeColors,
    chromeLinkColors,
    buttonColors,
    linkHoverColor
  } = useMemo(() => getThemeColors(color, mode), [color, mode]);
  const chromeContainerForLinkStyles = [chromeLinkStyles(chromeLinkColors), isRounded ? roundedBorderStyles : undefined];
  const chromeContainerStyles = [chromeStyles({ ...chromeColors
  }), isRounded ? roundedBorderStyles : undefined];
  const removeButton = isRemovable ? jsx("button", {
    css: [removeButtonStyles({ ...buttonColors
    }), isRounded ? roundedBorderStyles : undefined],
    tabIndex: 0,
    "aria-label": removeButtonLabel,
    onClick: handleRemoveRequest,
    onFocus: removingTag,
    onBlur: showingTag,
    onKeyPress: onKeyPress,
    type: "button",
    "data-testid": `close-button-${testId}`
  }, jsx(EditorCloseIcon, {
    label: "close tag",
    size: "small"
  })) : undefined;
  const tagCss = [...chromeContainerStyles, isLink ? chromeContainerForLinkStyles : undefined];
  const content = jsx(Content, _extends({}, props, {
    isRemovable: isRemovable,
    isLink: isLink,
    isRounded: isRounded,
    linkHoverColor: linkHoverColor
  }));
  return jsx(ExitingPersistence, null, !(status === TagStatus.Removed) && jsx(ShrinkOut, null, motion => {
    return jsx(BaseTag, {
      ref: mergeRefs(motion.ref, ref),
      testId: testId,
      tagCss: tagCss,
      "data-removable": true,
      "data-removing": status === TagStatus.Removing,
      role: isLink ? 'link' : undefined,
      before: jsx(Before, {
        isRounded: isRounded,
        elemBefore: elemBefore
      }),
      contentElement: content,
      after: removeButton
    });
  }));
});
const RemovableTag = /*#__PURE__*/memo( /*#__PURE__*/forwardRef((props, ref) => {
  return jsx(GlobalTheme.Consumer, null, tokens => {
    return jsx(InnerRemovableTag, _extends({}, props, {
      mode: tokens.mode,
      ref: ref
    }));
  });
}));
export default RemovableTag;