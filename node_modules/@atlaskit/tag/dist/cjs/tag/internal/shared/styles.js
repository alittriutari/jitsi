"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.linkStyles = exports.textStyles = exports.hasBeforeStyles = exports.hasAfterStyles = exports.chromeLinkStyles = exports.chromeStyles = exports.beforeElementStyles = exports.roundedBorderStyles = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _constants = require("../../../constants");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var roundedBorderStyles = {
  borderRadius: "".concat(_constants.defaultRoundedBorderRadius)
};
exports.roundedBorderStyles = roundedBorderStyles;
var beforeElementStyles = {
  position: 'absolute',
  left: 0,
  borderRadius: "".concat(_constants.defaultBorderRadius),
  alignItems: 'center',
  display: 'flex',
  justifyContent: 'center'
};
exports.beforeElementStyles = beforeElementStyles;

var chromeStyles = function chromeStyles(_ref) {
  var backgroundColor = _ref.backgroundColor,
      backgroundColorHover = _ref.backgroundColorHover,
      textColor = _ref.textColor,
      textColorHover = _ref.textColorHover;
  return {
    backgroundColor: backgroundColor,
    color: textColor,
    '&:hover': {
      backgroundColor: backgroundColorHover,
      color: textColorHover
    },
    '& button:hover': {
      backgroundColor: backgroundColor,
      color: textColor
    },
    '&>span:hover': {
      backgroundColor: backgroundColor,
      color: textColor
    },
    borderRadius: "".concat(_constants.defaultBorderRadius),
    cursor: 'default',
    display: 'inline-flex',
    position: 'relative',
    height: "".concat(_constants.tagHeight),
    lineHeight: 1,
    margin: "".concat(_constants.defaultMargin),
    padding: 0,
    overflow: 'hidden'
  };
};

exports.chromeStyles = chromeStyles;

var chromeLinkStyles = function chromeLinkStyles(_ref2) {
  var hoverBackgroundColor = _ref2.hoverBackgroundColor,
      hoverTextColor = _ref2.hoverTextColor,
      hoverBackgroundColorRemoval = _ref2.hoverBackgroundColorRemoval,
      hoverTextColorRemoval = _ref2.hoverTextColorRemoval,
      focusRingColor = _ref2.focusRingColor;
  return {
    '&>a:hover': {
      backgroundColor: hoverBackgroundColor,
      color: hoverTextColor
    },
    '&[data-removable="true"]:hover': {
      backgroundColor: hoverBackgroundColorRemoval,
      color: hoverTextColorRemoval
    },
    '&:focus-within': {
      boxShadow: "0 0 0 2px ".concat(focusRingColor),
      outline: 'none'
    },
    '&[data-removing="true"]:focus-within': {
      boxShadow: "0 0 0 2px transparent",
      outline: 'none'
    }
  };
};

exports.chromeLinkStyles = chromeLinkStyles;
var hasAfterStyles = {
  paddingRight: "".concat(_constants.textPaddingRight),
  maxWidth: "".concat(_constants.maxTextWidthUnitless - _constants.buttonWidthUnitless, "px")
};
exports.hasAfterStyles = hasAfterStyles;
var hasBeforeStyles = {
  paddingLeft: "".concat(_constants.textPaddingLeft)
};
exports.hasBeforeStyles = hasBeforeStyles;
var textStyles = {
  fontSize: _constants.textFontSize,
  fontWeight: 'normal',
  lineHeight: 1,
  paddingLeft: _constants.defaultTextPadding,
  paddingRight: _constants.defaultTextPadding,
  paddingTop: '2px',
  paddingBottom: '2px',
  borderRadius: _constants.defaultBorderRadius,
  maxWidth: _constants.maxTextWidth,
  overflow: 'hidden',
  textOverflow: 'ellipsis',
  whiteSpace: 'nowrap'
};
exports.textStyles = textStyles;

var linkStyles = function linkStyles(linkHoverColor) {
  return _objectSpread(_objectSpread({}, textStyles), {}, {
    ':not([data-color="standard"])': {
      color: 'inherit',
      textDecoration: 'underline'
    },
    textDecoration: 'none',
    '&:hover': {
      color: linkHoverColor
    },
    '&:focus': {
      outline: 'none'
    }
  });
};

exports.linkStyles = linkStyles;